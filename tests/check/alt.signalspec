with Seq(#a|#b, _)
def bare() = {
    alt _ {
        _ => {
            val(#a)
        }
        _ => {
            val(#b)
        }
    }
}

test @up(Seq(#a|#b, #x)) { val(#a) } | bare();

with Seq(#a|#b, dir)
def simple() = Seq(#a | #b, dir) {
    on val(x) {
        alt x {
            #a => {
                val(#a)
                val(#b)
            }
            #b => {
                val(#b)
                val(#a)
            }
        }
    }
}

test @both(Seq(#a|#b, #x)) { val(#b); val(#a) } | simple() | { val(#b) };
test @both(Seq(#a|#b, #x)) { val(#a); val(#b) } | simple() | { val(#a) };

with Seq(#a|#b|#x|#y, dir)
def tuple() = Seq((#a|#b, #a|#b|#x|#y), dir) {
    on val(z) {
        alt z {
            (#a, w) => {
                val(#a)
                val(w)
            }
            (#b, w) => {
                val(#b)
                val(w)
            }
        }
    }
}

test @both(Seq(#a|#b|#x|#y, #x)) { val(#b); val(#x) } | tuple() | { val((#b, #x)) };

with Seq(#a|#b, dir)
def ambiguous() = Seq(#a | #b, dir) {
    on val(x) {
        alt x {
            #b => {
                val(#a)
                val(#b)
                val(#a)
            }
            #a => {
                val(#a)
                val(#a)
                val(#b)
            }
        }
    }
}

// test @both(Seq(#a|#b)) { val(#a); val(#b); val(#a) } ambiguous() { val(#b) };
// test @both(Seq(#a|#b)) { val(#a); val(#a); val(#b) } ambiguous() { val(#a) };
// test fail @both(Seq(#a|#b)) { val(#a); val(#a); val(#a) } ambiguous() { val(#a) };
