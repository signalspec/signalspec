use super::ast;
use super::eval;
use std::char;

pub module -> ast::Module
    = _ entries:module_entry*
    { ast::Module { entries: entries } }

letstmt -> ast::LetDef
    = LET name:IDENTIFIER EQUALS value:expr
    { ast::LetDef(name, value) }

module_entry -> ast::ModuleEntry
    = l:letstmt { ast::ModuleEntry::Let(l) }
    / USE name:IDENTIFIER { ast::ModuleEntry::Use(name) }
    / WITH down_protocol:protocol_ref
      DEF name:IDENTIFIER LPAREN param: expr_tup RPAREN up_protocol:(COLON p:protocol_ref {p})? block:block
      { ast::ModuleEntry::WithDef(ast::Def { bottom:down_protocol, name:name, param:param, top:up_protocol, block:block }) }
    / PROTOCOL name:IDENTIFIER LPAREN params:(IDENTIFIER ** COMMA) COMMA? RPAREN entries:protocol_block
      { ast::ModuleEntry::Protocol(ast::Protocol { name:name, params: params, entries: entries }) }
    / t:test_block { ast::ModuleEntry::Test(t) }

protocol_ref -> ast::ProtocolRef
   = name:IDENTIFIER LPAREN param: expr_tup RPAREN { ast::ProtocolRef::Protocol { name: name, param: param } }
   / LPAREN t:(protocol_ref**COMMA) COMMA? RPAREN { ast::ProtocolRef::Tup(t) }
   / e:expr { ast::ProtocolRef::Type(e) }

block -> ast::Block
    = LBRACE lets:letstmt* actions:action**(SEMICOLON?) RBRACE
    { ast::Block{ lets:lets, actions:actions } }

    action -> ast::Action
        = REPEAT count:expr? block:block
            { ast::Action::Repeat(count.unwrap_or(ast::Expr::Ignore), block) }
        / ON expr:expr body:block?
            { ast::Action::On(expr, body) }
        / FOR items:(l:IDENTIFIER EQUALS r:expr { (l,r) })* body:block
            { ast::Action::For(items, body) }
        / ALT expr:expr LBRACE  arms:alt_arm* RBRACE
            { ast::Action::Alt(expr, arms) }
        / expr:varexpr LPAREN param:expr_tup RPAREN body:block?
            { ast::Action::Call(expr, param, body) }
        / expr:expr
            { ast::Action::Token(expr) }

        alt_arm -> ast::AltArm
          = expr:expr ARROW block:block
          { ast::AltArm { discriminant:expr, block:block } }

protocol_block -> Vec<ast::ProtocolEntry>
  = LBRACE entries:(entry:protocol_entry**(SEMICOLON?) {entry}) RBRACE
    { entries }

  protocol_entry -> ast::ProtocolEntry
     = e:expr { ast::ProtocolEntry::Message(e) }

// Expressions
expr -> ast::Expr
    = LPAREN e:expr_tup RPAREN {e}
    / valexpr

expr_tup -> ast::Expr
    = es:(expr ** COMMA) COMMA?
    { if es.len() == 1 { es.into_iter().next().unwrap() } else { ast::Expr::Tup(es) } }

#[cache]
pub valexpr -> ast::Expr
  = valexpr_flip

    valexpr_flip -> ast::Expr
        = l:valexpr_union TOKEN<"!"> r:valexpr_union { ast::Expr::Flip(box l, box r) }
        / TOKEN<"<:"> x:valexpr_union { ast::Expr::Flip(box x, box ast::Expr::Ignore) }
        / TOKEN<":>"> x:valexpr_union { ast::Expr::Flip(box ast::Expr::Ignore, box x) }
        / valexpr_union

    valexpr_union -> ast::Expr
        = u:valexpr_range ++ PIPE
        { if u.len() == 1 { u.into_iter().next().unwrap() } else { ast::Expr::Union(u) }}

    valexpr_range -> ast::Expr
        = rangeexpr
        / valexpr_sum

        rangeexpr -> ast::Expr
            = l:valexpr_sum TOKEN<".."> r:valexpr_sum
            { ast::Expr::Range(box l, box r) }

    #[cache]
    valexpr_sum -> ast::Expr
        = l:valexpr_product op:sum_op r:valexpr_sum
            { ast::Expr::Bin(box l, op, box r) }
        / valexpr_product

        sum_op -> eval::BinOp
          = TOKEN<"+"> { eval::BinOp::Add }
          / TOKEN<"-"> { eval::BinOp::Sub }

    #[cache]
    valexpr_product -> ast::Expr
        = l:valexpr_choose op:product_op r:valexpr_product
            { ast::Expr::Bin(box l, op, box r) }
        / valexpr_choose

        product_op -> eval::BinOp
          = TOKEN<"*"> { eval::BinOp::Mul }
          / TOKEN<"/"> { eval::BinOp::Div }

    valexpr_choose -> ast::Expr
        = e:valexpr_atom LBRACKET vs:(k:valexpr EQUALS v:valexpr { (k,v) })**COMMA COMMA? RBRACKET
            { ast::Expr::Choose(box e, vs) }
        / valexpr_call

    valexpr_call -> ast::Expr
        = e:valexpr_atom arg:(LPAREN arg:expr_tup RPAREN { arg })?
        {
          if let Some(arg) = arg {
            ast::Expr::Call(Box::new(e), Box::new(arg))
          } else {
            e
          }
        }

    valexpr_atom -> ast::Expr
        = literal_expr
        / ignoreliteral
        / concatexpr
        / varexpr
        / (LPAREN  v:valexpr RPAREN {v})

    ignoreliteral -> ast::Expr
        = UNDERSCORE { ast::Expr::Ignore }

    concatexpr -> ast::Expr
        = LBRACKET vs:(valexpr ++ COMMA) COMMA? RBRACKET
        { ast::Expr::Concat(vs) }

    varexpr -> ast::Expr = i:IDENTIFIER { ast::Expr::Var(i) }

    literal_expr -> ast::Expr
        = v:literal { ast::Expr::Value(v) }
        / LPAREN args:expr_tup RPAREN ARROW body:expr { ast::Expr::Func{ args: Box::new(args), body: Box::new(body) } }
        / s:STRING { ast::Expr::String(s) }

pub literal -> ast::Value
    = "#" i:IDENTIFIER { ast::Value::Symbol(i) }
    / "#" n:INTEGER { ast::Value::Integer(n) }
    / v:FLOAT u:unit { ast::Value::Number(v) }
    / bitsliteral

    bitsliteral -> ast::Value
        = "'h" v:(hexchar+) _ {
            ast::Value::Vector(v.iter().flat_map(|&i| {
              (0..4).map(move |b|
                ast::Value::Integer(((i & 1<<(3-b)) != 0) as i64))
            }).collect())
        }
        / "'" "b"? v:(binbit+) _
            { ast::Value::Vector(v.iter().map(|&b| ast::Value::Integer(b as i64)).collect()) }

        hexchar -> u8
            = c:$([0-9a-fA-F])
            { u8::from_str_radix(c, 16).unwrap() }

        binbit -> bool
            = "0" {false} / "1" {true}

    unit -> String
        = u:$([a-zA-Z]+) { u.to_string() }
        / "" { "".to_string() }

#[pub]
process -> ast::Process
  = b:block { ast::Process::Block(b) }
  / dir:literal_direction LPAREN t:protocol_ref RPAREN b:block
      { ast::Process::Literal(dir, t, b) }
  / name:IDENTIFIER param:(LPAREN param:expr_tup RPAREN {param})?
      { ast::Process::Call(name, param.unwrap_or(ast::Expr::Tup(vec![]))) }

    literal_direction -> ast::ProcessLiteralDirection
      = "@up"   { ast::ProcessLiteralDirection::Up }
      / "@dn"   { ast::ProcessLiteralDirection::Down }
      / "@both" { ast::ProcessLiteralDirection::Both }
      / "@roundtrip" { ast::ProcessLiteralDirection::RoundTrip }

test_block -> ast::Test
  = TEST fails:(KEYWORD<"fail">)? processes:process* SEMICOLON
  { ast::Test { should_fail: fails.is_some(), processes: processes } }

// Lexer

TERM = "\r"? "\n"
COMMENT = "//" (!TERM .)*
TERMINATOR = COMMENT? TERM
WHITESPACE
    = [\u{09}\u{0B}\u{0C}\u{20}\u{A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
    / "\\" TERM
_ = #quiet<(WHITESPACE / TERMINATOR)*>

TOKEN<t> = t _
COMMA      = TOKEN<",">
COLON      = TOKEN<":">
SEMICOLON  = TOKEN<";">
EQUALS     = TOKEN<"=">
ARROW      = TOKEN<"=>">
UNDERSCORE = TOKEN<"_">
PIPE       = TOKEN<"|">
LPAREN     = TOKEN<"(">
RPAREN     = TOKEN<")">
LBRACE     = TOKEN<"{">
RBRACE     = TOKEN<"}">
LBRACKET   = TOKEN<"[">
RBRACKET   = TOKEN<"]">

IDCHAR = [0-9a-zA-Z_]
KEYWORD<id> = id !IDCHAR _

USE      = KEYWORD<"use">
LET      = KEYWORD<"let">
DEF      = KEYWORD<"def">
PROTOCOL = KEYWORD<"protocol">
WITH     = KEYWORD<"with">
REPEAT   = KEYWORD<"repeat">
ON       = KEYWORD<"on">
FOR      = KEYWORD<"for">
ALT      = KEYWORD<"alt">
TEST     = KEYWORD<"test">

IDENTIFIER -> String = #quiet<i:$([a-zA-Z_][0-9a-zA-Z_]*) _ { i.to_string() }> / #expected("identifier")

INTEGER -> i64 = #quiet<i:$("-"?[0-9]+) _ { i.parse().unwrap() }> / #expected("integer")
FLOAT -> f64 = #quiet<i:$("-"?[0-9]+("."[0-9]+)?) _ { i.parse().unwrap() }> / #expected("float")

STRING -> String = #quiet<'"' s:doubleQuotedCharacter* '"' _ { s.into_iter().collect() }> / #expected("string")

  doubleQuotedCharacter -> char
    = simpleDoubleQuotedCharacter
    / unicodeEscapeSequence

  simpleDoubleQuotedCharacter -> char
    = !('"' / "\\" / TERM) c:$(.) { c.chars().next().unwrap() }

  unicodeEscapeSequence -> char
    = "\\u{" value:$([0-9a-fA-F]+) "}" {
        char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
      }
