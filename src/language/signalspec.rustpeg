use super::ast;
use super::eval;
use std::char;

#[export]
module -> ast::Module
    = _ imports:include* lets:letstmt* defs:def*
    { ast::Module{ imports: imports, lets: lets, defs: defs } }

include -> ast::UseDef
    = USE _ name:identifier BREAK
    { ast::UseDef(name) }

letstmt -> ast::LetDef
    = LET _ name:identifier _ "=" _ value:expr BREAK
    { ast::LetDef(name, value) }

def -> ast::ModuleEntry
    = DEF _ name:identifier _ "(" _ param: expr_tup _ ")" _ interface:(":" _ e:expr {e})? _ block:block BREAK
      { ast::ModuleEntry::Signal(ast::Def { name:name, param:param, interface:interface, block:block }) }
    / INTERFACE _ name:identifier _ entries:intf_block BREAK
      { ast::ModuleEntry::Interface(ast::Interface { name:name, entries: entries  }) }
    / t:test_block BREAK { ast::ModuleEntry::Test(t) }

#[pub]
block -> ast::Block
    = "{" _ lets:letstmt* actions:action ** (BREAK / (_ ";" _)) _ "}"
    { ast::Block{ lets:lets, actions:actions } }

    action -> ast::Action
        = REPEAT _ count:expr? _ block:block
            { ast::Action::Repeat(count.unwrap_or(ast::Expr::Ignore), block) }
        / ON _ expr:expr _ body:block?
            { ast::Action::On(expr, body) }
        / FOR _ items:(l:identifier _ "=" _ r:expr { (l,r) })* _  body:block
            { ast::Action::For(items, body) }
        / ALT _ expr:expr _ "{" _  arms:alt_arm ** BREAK _ "}"
            { ast::Action::Alt(expr, arms) }
        / expr:varexpr _ "(" _ param:expr_tup _ ")" _ body:block?
            { ast::Action::Call(expr, param, body) }
        / expr:expr
            { ast::Action::Token(expr) }

        alt_arm -> ast::AltArm
          = expr:expr _ "=>" _ block:block
          { ast::AltArm{ discriminant:expr, block:block } }

intf_block -> Vec<ast::InterfaceEntry>
  = _ "{" _ entries:(entry:intf_entry ** (BREAK / (_ ";" _)) {entry}) _ "}"
    { entries }

  intf_entry -> ast::InterfaceEntry
     = e:expr
     { ast::InterfaceEntry::Shape(e) }

// Expressions
#[pub]
expr -> ast::Expr
    = "(" _ e:expr_tup _")" {e}
    / valexpr

expr_tup -> ast::Expr
    = es:(expr ** COMMA) COMMA?
    { if es.len() == 1 { es.into_iter().next().unwrap() } else { ast::Expr::Tup(es) } }

#[pub]
#[cache]
valexpr -> ast::Expr
  = valexpr_flip

    valexpr_flip -> ast::Expr
        = l:valexpr_union _ "!" _ r:valexpr_union { ast::Expr::Flip(box l, box r) }
        / "<:" _ x:valexpr_union { ast::Expr::Flip(box x, box ast::Expr::Ignore) }
        / ":>" _ x:valexpr_union { ast::Expr::Flip(box ast::Expr::Ignore, box x) }
        / valexpr_union

    valexpr_union -> ast::Expr
        = u:valexpr_range ++ (_ "|" _)
        { if u.len() == 1 { u.into_iter().next().unwrap() } else { ast::Expr::Union(u) }}

    valexpr_range -> ast::Expr
        = rangeexpr
        / valexpr_sum

        rangeexpr -> ast::Expr
            = l:valexpr_sum _ ".." _ r:valexpr_sum
            { ast::Expr::Range(box l, box r) }

    #[cache]
    valexpr_sum -> ast::Expr
        = l:valexpr_product _ op:sum_op _ r:valexpr_sum
            { ast::Expr::Bin(box l, eval::BinOp::Add, box r) }
        / valexpr_product

        sum_op -> eval::BinOp
          = "+" { eval::BinOp::Add }
          / "-" { eval::BinOp::Sub }

    #[cache]
    valexpr_product -> ast::Expr
        = l:valexpr_choose _ op:product_op _ r:valexpr_product
            { ast::Expr::Bin(box l, eval::BinOp::Mul, box r) }
        / valexpr_choose

        product_op -> eval::BinOp
          = "*" { eval::BinOp::Mul }
          / "/" { eval::BinOp::Div }

    valexpr_choose -> ast::Expr
        = e:valexpr_atom _ "[" _ vs:(k:valexpr "=" _ v:valexpr { (k,v) })**COMMA COMMA? "]"
            { ast::Expr::Choose(box e, vs) }
        / valexpr_atom

    valexpr_atom -> ast::Expr
        = literal_expr
        / ignoreliteral
        / concatexpr
        / callexpr
        / varexpr
        / ("(" _ v:valexpr _ ")" _ {v})

    ignoreliteral -> ast::Expr
        = "_" { ast::Expr::Ignore }

    concatexpr -> ast::Expr
        = "[" _ vs:(valexpr ++ COMMA) COMMA? "]"
        { ast::Expr::Concat(vs) }

    callexpr -> ast::Expr
        = func:identifier _ "("_ arg:expr_tup _")"
        { ast::Expr::Call(func, Box::new(arg)) }

    varexpr -> ast::Expr
        = i:identifier
        { ast::Expr::Var(i) }

    literal_expr -> ast::Expr
        = v:literal { ast::Expr::Value(v) }
        / s:doubleQuotedString { ast::Expr::String(s) } // Not technically a value

    #[export]
    literal -> ast::Value
        = symbolliteral
        / integerliteral
        / bitsliteral
        / numberliteral

            symbolliteral -> ast::Value
                = "#" i:identifier
                { ast::Value::Symbol(i) }

            integerliteral -> ast::Value
                = "#" n:integer { ast::Value::Integer(n) }

            bitsliteral -> ast::Value
                = "'h" v:(hexchar+) {
                    ast::Value::Vector(v.iter().flat_map(|&i| {
                      (0..4).map(move |b|
                        ast::Value::Integer(((i & 1<<(3-b)) != 0) as i64))
                    }).collect())
                }
                / "'" "b"? v:(binbit+)
                    { ast::Value::Vector(v.iter().map(|&b| ast::Value::Integer(b as i64)).collect()) }

                hexchar -> u8
                    = [0-9a-fA-F]
                    { u8::from_str_radix(match_str, 16).unwrap() }

                binbit -> bool
                    = "0" {false} / "1" {true}

            numberliteral -> ast::Value
                = v:floatnumber _ u:unit
                { ast::Value::Number(v) }

            unitliteral = unit { () }

                unit -> String
                    = [a-zA-Z]+ { match_str.to_string() }
                    / "" { "".to_string() }

#[pub]
process -> ast::Process
  = b:block { ast::Process::Block(b) }
  / dir:literal_direction _ "(" _ t: expr _ ")" _ b:block
      { ast::Process::Literal(dir, t, b) }
  / name:identifier _ param:("(" _ param:expr_tup _ ")" {param})?
      { ast::Process::Call(name, param.unwrap_or(ast::Expr::Tup(vec![]))) }

    literal_direction -> ast::ProcessLiteralDirection
      = "@up"   { ast::ProcessLiteralDirection::Up }
      / "@dn"   { ast::ProcessLiteralDirection::Down }
      / "@both" { ast::ProcessLiteralDirection::Both }
      / "@roundtrip" { ast::ProcessLiteralDirection::RoundTrip }

test_block -> ast::Test
  = TEST _ fails:"fail"? _ processes:(process**_) ";"
  { ast::Test { should_fail: fails.is_some(), processes: processes } }

// Lexer

WHITESPACE
    = [\u{09}\u{0B}\u{0C}\u{20}\u{A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
    / "\\" TERM

TERM
    = "\r"? "\n"

COMMENT = "//" (!TERM .)*

TERMINATOR
    = COMMENT? TERM

BREAK = WHITESPACE* TERMINATOR _

COMMA = (_ "," _)

_ = (WHITESPACE / TERMINATOR)*

IDCHAR = [0-9a-zA-Z_]

USE    = "use"    !IDCHAR
LET    = "let"    !IDCHAR
DEF    = "def"    !IDCHAR
INTERFACE = "interface"    !IDCHAR
REPEAT = "repeat" !IDCHAR
ON     = "on"     !IDCHAR
FOR    = "for"    !IDCHAR
ALT   = "alt"   !IDCHAR
TEST   = "test"   !IDCHAR

identifier -> String = [a-zA-Z_][0-9a-zA-Z_]*
    { match_str.to_string() }

integer -> i64 = "-"?[0-9]+
    { match_str.parse().unwrap() }

floatnumber -> f64 = "-"?[0-9]+("."[0-9]+)?
    { match_str.parse().unwrap() }

doubleQuotedString -> String
  = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = simpleDoubleQuotedCharacter
  / unicodeEscapeSequence

simpleDoubleQuotedCharacter -> char
  = !('"' / "\\" / TERM) . { match_str.chars().next().unwrap() }

unicodeEscapeSequence -> char
  = "\\u{" value:([0-9a-fA-F]+ { u32::from_str_radix(match_str, 16)}) "}" {
      char::from_u32(value.unwrap()).unwrap()
    }
