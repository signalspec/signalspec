use super::ast;
use super::eval;
use std::char;

#[export]
module -> ast::Module
    = _ entries:module_entry*
    { ast::Module { entries: entries } }

letstmt -> ast::LetDef
    = LET _ name:identifier _ "=" _ value:expr BREAK
    { ast::LetDef(name, value) }

module_entry -> ast::ModuleEntry
    = l:letstmt { ast::ModuleEntry::Let(l) }
    / USE _ name:identifier BREAK { ast::ModuleEntry::Use(name) }
    / DEF _ name:identifier _ "(" _ param: expr_tup _ ")" _ protocol:(":" _ e:expr {e})? _ block:block BREAK
      { ast::ModuleEntry::Signal(ast::Def { name:name, param:param, protocol:protocol, block:block }) }
    / PROTOCOL _ name:identifier _ "(" _ param: expr_tup _ ")" _ entries:protocol_block BREAK
      { ast::ModuleEntry::Protocol(ast::Protocol { name:name, param: param, entries: entries  }) }
    / t:test_block BREAK { ast::ModuleEntry::Test(t) }

block -> ast::Block
    = "{" _ lets:letstmt* actions:action ** (BREAK / (_ ";" _)) _ "}"
    { ast::Block{ lets:lets, actions:actions } }

    action -> ast::Action
        = REPEAT _ count:expr? _ block:block
            { ast::Action::Repeat(count.unwrap_or(ast::Expr::Ignore), block) }
        / ON _ expr:expr _ body:block?
            { ast::Action::On(expr, body) }
        / FOR _ items:(l:identifier _ "=" _ r:expr { (l,r) })* _  body:block
            { ast::Action::For(items, body) }
        / ALT _ expr:expr _ "{" _  arms:alt_arm ** BREAK _ "}"
            { ast::Action::Alt(expr, arms) }
        / expr:varexpr _ "(" _ param:expr_tup _ ")" _ body:block?
            { ast::Action::Call(expr, param, body) }
        / expr:expr
            { ast::Action::Token(expr) }

        alt_arm -> ast::AltArm
          = expr:expr _ "=>" _ block:block
          { ast::AltArm{ discriminant:expr, block:block } }

protocol_block -> Vec<ast::ProtocolEntry>
  = _ "{" _ entries:(entry:protocol_entry ** (BREAK / (_ ";" _)) {entry}) _ "}"
    { entries }

  protocol_entry -> ast::ProtocolEntry
     = e:expr { ast::ProtocolEntry::Message(e) }

// Expressions
expr -> ast::Expr
    = "(" _ e:expr_tup _")" {e}
    / valexpr

expr_tup -> ast::Expr
    = es:(expr ** COMMA) COMMA?
    { if es.len() == 1 { es.into_iter().next().unwrap() } else { ast::Expr::Tup(es) } }

#[pub]
#[cache]
valexpr -> ast::Expr
  = valexpr_flip

    valexpr_flip -> ast::Expr
        = l:valexpr_union _ "!" _ r:valexpr_union { ast::Expr::Flip(box l, box r) }
        / "<:" _ x:valexpr_union { ast::Expr::Flip(box x, box ast::Expr::Ignore) }
        / ":>" _ x:valexpr_union { ast::Expr::Flip(box ast::Expr::Ignore, box x) }
        / valexpr_union

    valexpr_union -> ast::Expr
        = u:valexpr_range ++ (_ "|" _)
        { if u.len() == 1 { u.into_iter().next().unwrap() } else { ast::Expr::Union(u) }}

    valexpr_range -> ast::Expr
        = rangeexpr
        / valexpr_sum

        rangeexpr -> ast::Expr
            = l:valexpr_sum _ ".." _ r:valexpr_sum
            { ast::Expr::Range(box l, box r) }

    #[cache]
    valexpr_sum -> ast::Expr
        = l:valexpr_product _ op:sum_op _ r:valexpr_sum
            { ast::Expr::Bin(box l, op, box r) }
        / valexpr_product

        sum_op -> eval::BinOp
          = "+" { eval::BinOp::Add }
          / "-" { eval::BinOp::Sub }

    #[cache]
    valexpr_product -> ast::Expr
        = l:valexpr_choose _ op:product_op _ r:valexpr_product
            { ast::Expr::Bin(box l, op, box r) }
        / valexpr_choose

        product_op -> eval::BinOp
          = "*" { eval::BinOp::Mul }
          / "/" { eval::BinOp::Div }

    valexpr_choose -> ast::Expr
        = e:valexpr_atom _ "[" _ vs:(k:valexpr "=" _ v:valexpr { (k,v) })**COMMA COMMA? "]"
            { ast::Expr::Choose(box e, vs) }
        / valexpr_call

    valexpr_call -> ast::Expr
        = e:valexpr_atom arg:("("_ arg:expr_tup _")" { arg })?
        {
          if let Some(arg) = arg {
            ast::Expr::Call(Box::new(e), Box::new(arg))
          } else {
            e
          }
        }

    valexpr_atom -> ast::Expr
        = literal_expr
        / ignoreliteral
        / concatexpr
        / varexpr
        / ("(" _ v:valexpr _ ")" _ {v})

    ignoreliteral -> ast::Expr
        = "_" { ast::Expr::Ignore }

    concatexpr -> ast::Expr
        = "[" _ vs:(valexpr ++ COMMA) COMMA? "]"
        { ast::Expr::Concat(vs) }

    varexpr -> ast::Expr
        = i:identifier
        { ast::Expr::Var(i) }

    literal_expr -> ast::Expr
        = v:literal { ast::Expr::Value(v) }
        / "(" _ args:expr_tup _ ")"_ "=>" _ body:expr { ast::Expr::Func{ args: Box::new(args), body: Box::new(body) } }
        / s:doubleQuotedString { ast::Expr::String(s) } // Not technically a value

    #[export]
    literal -> ast::Value
        = symbolliteral
        / integerliteral
        / bitsliteral
        / numberliteral

            symbolliteral -> ast::Value
                = "#" i:identifier
                { ast::Value::Symbol(i) }

            integerliteral -> ast::Value
                = "#" n:integer { ast::Value::Integer(n) }

            bitsliteral -> ast::Value
                = "'h" v:(hexchar+) {
                    ast::Value::Vector(v.iter().flat_map(|&i| {
                      (0..4).map(move |b|
                        ast::Value::Integer(((i & 1<<(3-b)) != 0) as i64))
                    }).collect())
                }
                / "'" "b"? v:(binbit+)
                    { ast::Value::Vector(v.iter().map(|&b| ast::Value::Integer(b as i64)).collect()) }

                hexchar -> u8
                    = c:$([0-9a-fA-F])
                    { u8::from_str_radix(c, 16).unwrap() }

                binbit -> bool
                    = "0" {false} / "1" {true}

            numberliteral -> ast::Value
                = v:floatnumber _ u:unit
                { ast::Value::Number(v) }

            unitliteral = unit { () }

                unit -> String
                    = u:$([a-zA-Z]+) { u.to_string() }
                    / "" { "".to_string() }

#[pub]
process -> ast::Process
  = b:block { ast::Process::Block(b) }
  / dir:literal_direction _ "(" _ t: expr _ ")" _ b:block
      { ast::Process::Literal(dir, t, b) }
  / name:identifier _ param:("(" _ param:expr_tup _ ")" {param})?
      { ast::Process::Call(name, param.unwrap_or(ast::Expr::Tup(vec![]))) }

    literal_direction -> ast::ProcessLiteralDirection
      = "@up"   { ast::ProcessLiteralDirection::Up }
      / "@dn"   { ast::ProcessLiteralDirection::Down }
      / "@both" { ast::ProcessLiteralDirection::Both }
      / "@roundtrip" { ast::ProcessLiteralDirection::RoundTrip }

test_block -> ast::Test
  = TEST _ fails:"fail"? _ processes:(process**_) ";"
  { ast::Test { should_fail: fails.is_some(), processes: processes } }

// Lexer

WHITESPACE
    = [\u{09}\u{0B}\u{0C}\u{20}\u{A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
    / "\\" TERM

TERM
    = "\r"? "\n"

COMMENT = "//" (!TERM .)*

TERMINATOR
    = COMMENT? TERM

BREAK = WHITESPACE* TERMINATOR _

COMMA = (_ "," _)

_ = (WHITESPACE / TERMINATOR)*

IDCHAR = [0-9a-zA-Z_]

USE    = "use"    !IDCHAR
LET    = "let"    !IDCHAR
DEF    = "def"    !IDCHAR
PROTOCOL = "protocol"    !IDCHAR
REPEAT = "repeat" !IDCHAR
ON     = "on"     !IDCHAR
FOR    = "for"    !IDCHAR
ALT   = "alt"   !IDCHAR
TEST   = "test"   !IDCHAR

identifier -> String = i:$([a-zA-Z_][0-9a-zA-Z_]*)
    { i.to_string() }

integer -> i64 = i:$("-"?[0-9]+)
    { i.parse().unwrap() }

floatnumber -> f64 = i:$("-"?[0-9]+("."[0-9]+)?)
    { i.parse().unwrap() }

doubleQuotedString -> String
  = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = simpleDoubleQuotedCharacter
  / unicodeEscapeSequence

simpleDoubleQuotedCharacter -> char
  = !('"' / "\\" / TERM) c:$(.) { c.chars().next().unwrap() }

unicodeEscapeSequence -> char
  = "\\u{" value:$([0-9a-fA-F]+) "}" {
      char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
    }
