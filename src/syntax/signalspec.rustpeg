use super::{ ast, BinOp };
use std::char;
use codemap::{ Span, Spanned };

#![arguments(file_span: Span)]

spanned<inner>
  = start:#position node:inner end:#position
  { Spanned { node, span: file_span.subspan(start as u64, end as u64) } }

pub module -> ast::Module
    = _ entries:spanned<module_entry>**__ _
    { ast::Module { entries: entries } }

letstmt -> ast::LetDef
    = LET _ name:IDENTIFIER _ EQUALS _ value:expr
    { ast::LetDef(name, value) }

module_entry -> ast::ModuleEntry
    = l:letstmt { ast::ModuleEntry::Let(l) }
    / USE _ name:IDENTIFIER { ast::ModuleEntry::Use(name) }
    / WITH _ bottom:protocol_ref _
      DEF _ name:IDENTIFIER _ param:expr_tup _ EQUALS _ processes:process_chain
      { ast::ModuleEntry::WithDef(ast::Def { bottom, name, param, processes }) }
    / PROTOCOL _ name:IDENTIFIER _ param:expr_tup _ entries:protocol_block
      { ast::ModuleEntry::Protocol(ast::Protocol { name, param, entries }) }
    / t:test_block { ast::ModuleEntry::Test(t) }


pub primitive_header -> ast::PrimitiveHeader
  = WITH _ down_protocol:protocol_ref _ DEF _ name:IDENTIFIER _ param:expr_tup _ up_protocol:(COLON _ p:protocol_ref {p})?
    { ast::PrimitiveHeader { bottom:down_protocol, name:name, param:param, top:up_protocol } }

protocol_ref -> ast::ProtocolRef
   = name:IDENTIFIER _ param:expr_tup { ast::ProtocolRef { name: name, param: param } }

block -> ast::Block
    = LBRACE _ lets:spanned<letstmt>**_ _ actions:spanned<action>**(_ (SEMICOLON _)?) _ RBRACE
    { ast::Block{ lets:lets, actions:actions } }

    action -> ast::Action
        = REPEAT _ count:expr? _ block:block
            { ast::Action::Repeat(count, block) }
        / ON _ name:IDENTIFIER _ expr:expr_tup _ body:block?
            { ast::Action::On(name, expr, body) }
        / FOR _ items:(l:IDENTIFIER _ EQUALS _ r:expr { (l,r) })**__ _ body:block
            { ast::Action::For(items, body) }
        / ALT _ expr:expr _ arms:BLOCK<alt_arm**__>
            { ast::Action::Alt(expr, arms) }
        / p:process_chain
            { ast::Action::Process(p) }

        alt_arm -> ast::AltArm
          = expr:expr _ ARROW _ block:block
          { ast::AltArm { discriminant:expr, block:block } }

protocol_block -> Vec<ast::ProtocolEntry> = BLOCK<COMMASEP<protocol_entry>>

  protocol_entry -> ast::ProtocolEntry
     = n:IDENTIFIER _ e:expr_tup { ast::ProtocolEntry::Message(n, e) }

// Expressions
expr -> ast::SpannedExpr
    = expr_tup
    / valexpr

expr_tup -> ast::SpannedExpr
    = es:spanned<PARENTHESIZED<COMMASEP<expr>>>
    { if es.len() == 1 { es.node.into_iter().next().unwrap() } else { Spanned { node: ast::Expr::Tup(es.node), span: es.span } } }

#[cache]
pub valexpr -> ast::SpannedExpr
  = valexpr_flip

    valexpr_flip -> ast::SpannedExpr
        = spanned<
          l:valexpr_union _ TOKEN<"!"> _ r:valexpr_union { ast::Expr::Flip(Some(box l), Some(box r)) }
          / t:TOKEN<"<:"> _ x:valexpr_union { ast::Expr::Flip(Some(box x), None) }
          / t:TOKEN<":>"> _ x:valexpr_union { ast::Expr::Flip(None, Some(box x)) }
        >
        / valexpr_union

    valexpr_union -> ast::SpannedExpr
        = spanned<u:valexpr_range **<2,> (_ PIPE _) { ast::Expr::Union(u) }>
        / valexpr_range

    valexpr_range -> ast::SpannedExpr
        = spanned<l:valexpr_sum _ TOKEN<".."> _ r:valexpr_sum { ast::Expr::Range(box l, box r) }>
        / valexpr_sum

    #[cache]
    valexpr_sum -> ast::SpannedExpr
        = spanned<l:valexpr_product _ op:sum_op _ r:valexpr_sum { ast::Expr::Bin(box l, op, box r) }>
        / valexpr_product

        sum_op -> BinOp
          = TOKEN<"+"> { BinOp::Add }
          / TOKEN<"-"> { BinOp::Sub }

    #[cache]
    valexpr_product -> ast::SpannedExpr
        = spanned<l:valexpr_choose _ op:product_op _ r:valexpr_product { ast::Expr::Bin(box l, op, box r) }>
        / valexpr_choose

        product_op -> BinOp
          = TOKEN<"*"> { BinOp::Mul }
          / TOKEN<"/"> { BinOp::Div }

    valexpr_choose -> ast::SpannedExpr
        = spanned<e:valexpr_atom _ vs:BRACKETED<COMMASEP<(k:valexpr _ EQUALS _ v:valexpr { (k,v) })>> { ast::Expr::Choose(box e, vs) }>
        / valexpr_call

    valexpr_call -> ast::SpannedExpr
        = spanned<e:valexpr_atom arg:expr_tup { ast::Expr::Call(Box::new(e), Box::new(arg)) }>
        / valexpr_atom

    valexpr_atom -> ast::SpannedExpr
      = spanned<literal_expr / ignoreliteral / concatexpr / varexpr>
      / PARENTHESIZED<valexpr>

    ignoreliteral -> ast::Expr
        = UNDERSCORE { ast::Expr::Ignore }

    concatexpr -> ast::Expr = vs:BRACKETED<COMMASEP<concat_elem>> { ast::Expr::Concat(vs) }
        concat_elem -> (Option<usize>, ast::SpannedExpr) = w:(w:INTEGER COLON {w as usize})? e:valexpr { (w, e) }

    varexpr -> ast::Expr = i:IDENTIFIER { ast::Expr::Var(i) }

    literal_expr -> ast::Expr
        = v:literal { ast::Expr::Value(v) }
        / args:expr_tup _ ARROW _ body:expr { ast::Expr::Func { args: Box::new(args), body: Box::new(body) } }
        / s:STRING { ast::Expr::String(s) }

pub literal -> ast::Value
    = "#" i:IDENTIFIER { ast::Value::Symbol(i) }
    / v:FLOAT u:unit { ast::Value::Number(v) }
    / n:INTEGER { ast::Value::Integer(n) }
    / bitsliteral

    bitsliteral -> ast::Value
        = "'h" v:(hexchar+) {
            ast::Value::Vector(v.iter().flat_map(|&i| {
              (0..4).map(move |b|
                ast::Value::Integer(((i & 1<<(3-b)) != 0) as i64))
            }).collect())
        }
        / "'" "b"? v:(binbit+)
            { ast::Value::Vector(v.iter().map(|&b| ast::Value::Integer(b as i64)).collect()) }

        hexchar -> u8
            = c:$([0-9a-fA-F])
            { u8::from_str_radix(c, 16).unwrap() }

        binbit -> bool
            = "0" {false} / "1" {true}

    unit -> String
        = u:$([a-zA-Z]+) { u.to_string() }
        / "" { "".to_string() }

#[pub]
process_chain -> Vec<ast::Process>
  = process ++ (_ PIPE _)

  process -> ast::Process
    = proto:protocol_ref _ block:block { ast::Process::Seq(proto, block) }
    / name:IDENTIFIER _ param:expr_tup { ast::Process::Call(name, param) }
    / block:block { ast::Process::InferSeq(block) }
    / dir:literal_direction _ t:PARENTHESIZED<protocol_ref> _ b:block
        { ast::Process::Literal(dir, t, b) }

    literal_direction -> ast::ProcessLiteralDirection
      = "@up"   { ast::ProcessLiteralDirection::Up }
      / "@dn"   { ast::ProcessLiteralDirection::Down }
      / "@both" { ast::ProcessLiteralDirection::Both }
      / "@roundtrip" { ast::ProcessLiteralDirection::RoundTrip }

test_block -> ast::Test
  = TEST _ fails:(KEYWORD<"fail"> __)? processes:process_chain _ SEMICOLON
  { ast::Test { should_fail: fails.is_some(), processes: processes } }

// Lexer

TERM = "\r"? "\n"
COMMENT = "//" (!TERM .)*
TERMINATOR = COMMENT? TERM
WHITESPACE
    = [\u{09}\u{0B}\u{0C}\u{20}\u{A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
    / "\\" TERM
_ = #quiet<(WHITESPACE / TERMINATOR)*>
__ = #quiet<(WHITESPACE / TERMINATOR)+>

TOKEN<t> = t
COMMA      = TOKEN<",">
COLON      = TOKEN<":">
SEMICOLON  = TOKEN<";">
EQUALS     = TOKEN<"=">
ARROW      = TOKEN<"=>">
UNDERSCORE = TOKEN<"_">
PIPE       = TOKEN<"|">
LPAREN     = TOKEN<"(">
RPAREN     = TOKEN<")">
LBRACE     = TOKEN<"{">
RBRACE     = TOKEN<"}">
LBRACKET   = TOKEN<"[">
RBRACKET   = TOKEN<"]">

PARENTHESIZED<x>  = "(" _ v:x _ ")" {v}
BLOCK<x>          = "{" _ v:x _ "}" {v}
BRACKETED<x>      = "[" _ v:x _ "]" {v}
COMMASEP<x>       = v:(x ** (_ "," _)) (_ ",")? {v}

IDCHAR = [0-9a-zA-Z_]
KEYWORD<id> = id !IDCHAR

USE      = KEYWORD<"use">
LET      = KEYWORD<"let">
DEF      = KEYWORD<"def">
PROTOCOL = KEYWORD<"protocol">
WITH     = KEYWORD<"with">
REPEAT   = KEYWORD<"repeat">
ON       = KEYWORD<"on">
FOR      = KEYWORD<"for">
ALT      = KEYWORD<"alt">
TEST     = KEYWORD<"test">

IDENTIFIER -> String = #quiet<i:$([a-zA-Z_][0-9a-zA-Z_]*) { i.to_string() }> / #expected("identifier")

INTEGER -> i64 = #quiet<i:$("-"?[0-9]+) { i.parse().unwrap() }> / #expected("integer")
FLOAT -> f64 = #quiet<i:$("-"?[0-9]+ "." !"." [0-9]*) { i.parse().unwrap() }> / #expected("float")

STRING -> String = #quiet<'"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }> / #expected("string")

  doubleQuotedCharacter -> char
    = simpleDoubleQuotedCharacter
    / unicodeEscapeSequence

  simpleDoubleQuotedCharacter -> char
    = !('"' / "\\" / TERM) c:$(.) { c.chars().next().unwrap() }

  unicodeEscapeSequence -> char
    = "\\u{" value:$([0-9a-fA-F]+) "}" {
        char::from_u32(u32::from_str_radix(value, 16).unwrap()).unwrap()
      }
