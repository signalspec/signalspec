{
	use std;
	use ast;
	use eval;
	use std::num::from_str_radix;
}

#[export]
module -> ast::Module
  = __ imports:include* lets:letstmt* defs:def* !.
  { ast::Module{ imports: imports, lets: lets, defs: defs } }

include  -> ast::UseDef
	= "use" _ name:identifier __
	{ ast::UseDef(name) }

varinit -> ast::Expr
	= _ "=" _ e:valexpr { e }

letstmt -> ast::LetDef
	= "let" _ name:identifier value:varinit BREAK
	{ ast::LetDef(name, value) }

def -> ast::Def
	= "def" _ name:identifier _ "(" params: paramdef* ")" _ block:block
	{ ast::Def{ name:name, params:params, block:block } }

	block -> ast::Block
		= "{" __ lets:letstmt* actions:action* "}" __
		{ ast::Block{ lets:lets, actions:actions } }

	paramdef -> ast::ParamDef
		= name:identifier _ ":" _ tp:typeexpr init:varinit? commasep
		{ ast::ParamDef{name:name, tp:tp, default:init} }

	action -> ast::Action
		= entity:varexpr _ "(" arg:valexpr? ")" __ body: actionbody?
		{ ast::Action { entity: entity, posarg: arg, body: body } }

		actionbody -> ast::ActionBody
			= "|" args: (n:identifier commasep {n})* "|" __ block: block
			{ ast::ActionBody{ param_names: args, block: block } }

#[export]
typeexpr -> ast::TypeExpr
	= symboltype
	/ bitstype
	/ numbertype
	/ entitytype

	symboltype -> ast::TypeExpr
		= "enum" _ "(" vs:symbol_list ")" _
		{ ast::SymbolType }

		symbol_list -> ~[ast::Value]
			= __ vs:(i:symbolliteral commasep { i })*
			{ vs }

	bitstype -> ast::TypeExpr
		= "bits" _ "(" _ val:integer ")" _
		{ ast::BitsType(val as uint) }

	numbertype -> ast::TypeExpr
		= "number" _ "(" units:unitliteral ")" _
		{ ast::NumberType }

	entitytype -> ast::TypeExpr
		= tp:identifier _
		{ ast::EntityType }

// Expressions

#[export]
valexpr -> ast::Expr
	= valexpr_flip

	valexpr_flip -> ast::Expr
		= l:valexpr_range "!" _ r:valexpr_range { ast::FlipExpr(~l, ~r) }
		/ "<:" _ x:valexpr_range { ast::FlipExpr(~x, ~ast::IgnoreExpr) }
		/ ":>" _ x:valexpr_range { ast::FlipExpr(~ast::IgnoreExpr, ~x) }
		/ valexpr_range

	valexpr_range -> ast::Expr
		= rangeexpr
		/ valexpr_sum

		rangeexpr -> ast::Expr
			= l:valexpr_sum ".." _ r:valexpr_sum
			{ ast::RangeExpr(~l, ~r) }

	valexpr_sum -> ast::Expr
		= l:valexpr_product op:[+] _ r:valexpr_sum
			{ ast::BinExpr(~l, eval::BiAdd, ~r) }
		/ valexpr_product

	valexpr_product -> ast::Expr
		= l:valexpr_choose op:[*] _ r:valexpr_product
			{ ast::BinExpr(~l, eval::BiMul, ~r) }
		/ valexpr_choose

	valexpr_choose -> ast::Expr
		= e:valexpr_atom "[" vs:(k:valexpr "=" _ v:valexpr commasep { (k,v) })* "]"
			{ ast::ChooseExpr(~e, vs) }
		/ valexpr_atom

	valexpr_atom -> ast::Expr
		= literal
		/ ignoreliteral
		/ concatexpr
		/ varexpr
		/ ("(" _ v:valexpr ")" _ {v})

	concatexpr -> ast::Expr
		= "[" vs:(v:valexpr commasep {v})+ "]" _
		{ ast::ConcatExpr(vs) }

	varexpr -> ast::Expr
		= i:identifier accessors:("." i:identifier {i} )*
		{ accessors.move_iter().fold(ast::VarExpr(i), |base, accessor| ast::DotExpr(~base, accessor)) }

	literal -> ast::Expr
		= v: (
			  symbolliteral
			/ bitsliteral
			/ numberliteral
		)
		{ ast::ValueExpr(v) }

			ignoreliteral -> ast::Expr
				= "ignore" _
				{ ast::IgnoreExpr }

			symbolliteral -> ast::Value
				= "#" i:identifier _
				{ ast::SymbolValue(i) }

			bitsliteral -> ast::Value
				= "'h" v:(hexchar+) _ {
					ast::BitsValue(std::slice::from_fn(v.len()*4, |i| {
						let n = i/4;
						let b = i%4;
						v[n] & (1 << (4-b)) != 0
					}))
				}
				/ "'" "b"? v:(binbit+) _    { ast::BitsValue(v) }

				hexchar -> u8
					= [0-9a-fA-F]
					{ from_str_radix::<u8>(match_str, 16).unwrap() }

				binbit -> bool
					= "0" {false} / "1" {true}

			numberliteral -> ast::Value
				= v:floatnumber _ u:unit _
				{ ast::NumberValue(v) }

			unitliteral = unit { () }

				unit -> ~str
					= [a-zA-Z]+ { match_str.to_owned() }
				    / "" { ~"" }

// Lexer

commasep = ( "," / TERMINATOR / &(__ [)\]]) ) __

WHITESPACE
  = [\u0009\u000B\u000C\u0020\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]
  / "\\" TERM

TERM
  = "\r"? "\n"

TERMINATOR
  = (comment? TERM)+

BREAK = _ TERMINATOR __

comment = "//" (!TERM .)*

_ = WHITESPACE*
__ = (WHITESPACE / TERMINATOR)*

identifier -> ~str = [a-zA-Z_][0-9a-zA-Z_]*
	{ match_str.to_owned() }

integer -> int = "-"?[0-9]+
	{ from_str::<int>(match_str).unwrap() }

floatnumber -> f64 = "-"?[0-9]+("."[0-9]+)?
	{ from_str::<f64>(match_str).unwrap() }
