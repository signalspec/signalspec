use ast;
use eval;
use std::num::from_str_radix;
use std::char;

#[export]
module -> ast::Module
    = _ imports:include* lets:letstmt* defs:def*
    { ast::Module{ imports: imports, lets: lets, defs: defs } }

include -> ast::UseDef
    = USE _ name:identifier BREAK
    { ast::UseDef(name) }

letstmt -> ast::LetDef
    = LET _ name:identifier _ "=" _ value:expr BREAK
    { ast::LetDef(name, value) }

def -> ast::Def
    = DEF _ name:identifier _ "(" _ param: expr_tup _ ")" _ block:block BREAK
    { ast::Def{ name:name, param:param, block:block } }

    block -> ast::Block
        = "{" _ lets:letstmt* actions:action ** BREAK _ "}"
        { ast::Block{ lets:lets, actions:actions } }

    action -> ast::Action
        = REPEAT _ count:expr? _ block:block
            { ast::Action::Repeat(count.unwrap_or(ast::Expr::Ignore), block) }
        / ON _ expr:expr _ body:block?
            { ast::Action::On(expr, body) }
        / expr:varexpr _ "(" _ param:expr_tup _ ")" _ body:block?
            { ast::Action::Call(expr, param, body) }
        / expr:expr body:block?
            { ast::Action::Token(expr, body) }

// Expressions

#[export]
expr -> ast::Expr
    = "(" _ e:expr_tup _")" {e}
    / valexpr

expr_tup -> ast::Expr
    = es:(expr ** COMMA) COMMA?
    { if es.len() == 1 { es.into_iter().next().unwrap() } else { ast::Expr::Tup(es) } }

#[export]
valexpr -> ast::Expr
  = valexpr_flip

    valexpr_flip -> ast::Expr
        = l:valexpr_range _ "!" _ r:valexpr_range { ast::Expr::Flip(box l, box r) }
        / "<:" _ x:valexpr_range { ast::Expr::Flip(box x, box ast::Expr::Ignore) }
        / ":>" _ x:valexpr_range { ast::Expr::Flip(box ast::Expr::Ignore, box x) }
        / valexpr_range

    valexpr_range -> ast::Expr
        = rangeexpr
        / valexpr_sum

        rangeexpr -> ast::Expr
            = l:valexpr_sum _ ".." _ r:valexpr_sum
            { ast::Expr::Range(box l, box r) }

    valexpr_sum -> ast::Expr
        = l:valexpr_product _ op:[+] _ r:valexpr_sum
            { ast::Expr::Bin(box l, eval::BinOp::Add, box r) }
        / valexpr_product

    valexpr_product -> ast::Expr
        = l:valexpr_choose _ op:[*] _ r:valexpr_product
            { ast::Expr::Bin(box l, eval::BinOp::Mul, box r) }
        / valexpr_choose

    valexpr_choose -> ast::Expr
        = e:valexpr_atom _ "[" _ vs:(k:valexpr "=" _ v:valexpr { (k,v) })**COMMA COMMA? "]"
            { ast::Expr::Choose(box e, vs) }
        / valexpr_atom

    valexpr_atom -> ast::Expr
        = literal_expr
        / ignoreliteral
        / concatexpr
        / varexpr
        / ("(" _ v:valexpr _ ")" _ {v})

    concatexpr -> ast::Expr
        = "[" _ vs:(valexpr ++ COMMA) COMMA? "]"
        { ast::Expr::Concat(vs) }

    varexpr -> ast::Expr
        = i:identifier accessors:("." i:identifier {i} )*
        { accessors.into_iter().fold(ast::Expr::Var(i), |base, accessor| ast::Expr::Dot(box base, accessor)) }

    literal_expr -> ast::Expr
        = v:literal { ast::Expr::Value(v) }
        / s:doubleQuotedString { ast::Expr::String(s) } // Not technically a value

    #[export]
    literal -> ast::Value
        = symbolliteral
        / integerliteral
        / bitsliteral
        / numberliteral

            ignoreliteral -> ast::Expr
                = "ignore"
                { ast::Expr::Ignore }

            symbolliteral -> ast::Value
                = "#" i:identifier
                { ast::Value::Symbol(i) }

            integerliteral -> ast::Value
                = "#" n:integer { ast::Value::Integer(n) }

            bitsliteral -> ast::Value
                = "'h" v:(hexchar+) {
                    ast::Value::Vector(Vec::from_fn(v.len()*4, |i| {
                        let n = i/4;
                        let b = i%4;
                        ast::Value::Integer((v.as_slice()[n] & (1 << (4-b))) as i64)
                    }))
                }
                / "'" "b"? v:(binbit+)
                    { ast::Value::Vector(v.iter().map(|&b| ast::Value::Integer(b as i64)).collect()) }

                hexchar -> u8
                    = [0-9a-fA-F]
                    { from_str_radix::<u8>(match_str, 16).unwrap() }

                binbit -> bool
                    = "0" {false} / "1" {true}

            numberliteral -> ast::Value
                = v:floatnumber _ u:unit
                { ast::Value::Number(v) }

            unitliteral = unit { () }

                unit -> String
                    = [a-zA-Z]+ { match_str.to_string() }
                    / "" { "".to_string() }

// Lexer

WHITESPACE
    = [\u{09}\u{0B}\u{0C}\u{20}\u{A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}]
    / "\\" TERM

TERM
    = "\r"? "\n"

COMMENT = "//" (!TERM .)*

TERMINATOR
    = COMMENT? TERM

BREAK = WHITESPACE* TERMINATOR _

COMMA = (_ "," _)

_ = (WHITESPACE / TERMINATOR)*

IDCHAR = [0-9a-zA-Z_]

USE    = "use"    !IDCHAR
LET    = "let"    !IDCHAR
DEF    = "def"    !IDCHAR
REPEAT = "repeat" !IDCHAR
ON     = "on"     !IDCHAR

identifier -> String = [a-zA-Z_][0-9a-zA-Z_]*
    { match_str.to_string() }

integer -> i64 = "-"?[0-9]+
    { match_str.parse().unwrap() }

floatnumber -> f64 = "-"?[0-9]+("."[0-9]+)?
    { match_str.parse().unwrap() }

doubleQuotedString -> String
  = '"' s:doubleQuotedCharacter* '"' { s.into_iter().collect() }

doubleQuotedCharacter -> char
  = simpleDoubleQuotedCharacter
  / unicodeEscapeSequence

simpleDoubleQuotedCharacter -> char
  = !('"' / "\\" / TERM) . { match_str.char_at(0) }

unicodeEscapeSequence -> char
  = "\\u{" value:([0-9a-fA-F]+ { from_str_radix::<int>(match_str, 16)}) "}" {
      char::from_u32(value.unwrap() as u32).unwrap()
    }
