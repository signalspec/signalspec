{
	use ast;
	use eval;
	use std::num::from_str_radix;
}

use ast;
use eval;
use std::num::from_str_radix;

#[export]
module -> ast::Module
  = __ imports:include* lets:letstmt* defs:def* !.
  { ast::Module{ imports: imports, lets: lets, defs: defs } }

include  -> ast::UseDef
	= "use" _ name:identifier __
	{ ast::UseDef(name) }

varinit -> ast::Expr
	= _ "=" _ e:valexpr { e }

letstmt -> ast::LetDef
	= "let" _ name:identifier value:varinit BREAK
	{ ast::LetDef(name, value) }

def -> ast::Def
	= "def" _ name:identifier _ "(" params: paramdef* ")" _ block:block
	{ ast::Def{ name:name, params:params, block:block } }

	block -> ast::Block
		= "{" __ lets:letstmt* actions:action* "}" __
		{ ast::Block{ lets:lets, actions:actions } }

	paramdef -> ast::ParamDef
		= name:identifier _ ":" _ tp:typeexpr init:varinit? commasep
		{ ast::ParamDef{name:name, tp:tp, default:init} }

	action -> ast::Action
		= entity:varexpr ":" name:identifier call:actionargs
			{ ast::ActionToken(entity, name, call) }
		/ expr:varexpr call:actionargs
			{ ast::ActionCall(expr, call) }

		// TODO: multiple arguments, keyword arguments
		actionargs -> ast::Call
			= "(" params:valexpr* ")" __ body: actionbody?
			{ ast::Call{ positional:params, body: body } }

		actionbody -> ast::ActionBody
			= "|" args: (n:identifier commasep {n})* "|" __ block: block
			{ ast::ActionBody{ param_names: args, block: block } }

#[export]
typeexpr -> ast::TypeExpr
	= symboltype
	/ numbertype
	/ entitytype

	symboltype -> ast::TypeExpr
		= "enum" _ "(" vs:symbol_list ")" _
		{ ast::SymbolType }

		symbol_list -> Vec<ast::Value>
			= __ vs:(i:symbolliteral commasep { i })*
			{ vs }

	numbertype -> ast::TypeExpr
		= "number" _ "(" units:unitliteral ")" _
		{ ast::NumberType }

	entitytype -> ast::TypeExpr
		= tp:identifier _
		{ ast::EntityType }

// Expressions

#[export]
valexpr -> ast::Expr
	= valexpr_flip

	valexpr_flip -> ast::Expr
		= l:valexpr_range "!" _ r:valexpr_range { ast::FlipExpr(box l, box r) }
		/ "<:" _ x:valexpr_range { ast::FlipExpr(box x, box ast::IgnoreExpr) }
		/ ":>" _ x:valexpr_range { ast::FlipExpr(box ast::IgnoreExpr, box x) }
		/ valexpr_range

	valexpr_range -> ast::Expr
		= rangeexpr
		/ valexpr_sum

		rangeexpr -> ast::Expr
			= l:valexpr_sum ".." _ r:valexpr_sum
			{ ast::RangeExpr(box l, box r) }

	valexpr_sum -> ast::Expr
		= l:valexpr_product op:[+] _ r:valexpr_sum
			{ ast::BinExpr(box l, eval::BiAdd, box r) }
		/ valexpr_product

	valexpr_product -> ast::Expr
		= l:valexpr_choose op:[*] _ r:valexpr_product
			{ ast::BinExpr(box l, eval::BiMul, box r) }
		/ valexpr_choose

	valexpr_choose -> ast::Expr
		= e:valexpr_atom "[" vs:(k:valexpr "=" _ v:valexpr commasep { (k,v) })* "]"
			{ ast::ChooseExpr(box e, vs) }
		/ valexpr_atom

	valexpr_atom -> ast::Expr
		= literal_expr
		/ ignoreliteral
		/ concatexpr
		/ varexpr
		/ ("(" _ v:valexpr ")" _ {v})

	concatexpr -> ast::Expr
		= "[" vs:(v:valexpr commasep {v})+ "]" _
		{ ast::ConcatExpr(vs) }

	varexpr -> ast::Expr
		= i:identifier accessors:("." i:identifier {i} )*
		{ accessors.move_iter().fold(ast::VarExpr(i), |base, accessor| ast::DotExpr(box base, accessor)) }

	literal_expr -> ast::Expr
		= v:literal { ast::ValueExpr(v) }

	#[export]
	literal -> ast::Value
		= symbolliteral
		/ integerliteral
		/ bitsliteral
		/ numberliteral

			ignoreliteral -> ast::Expr
				= "ignore" _
				{ ast::IgnoreExpr }

			symbolliteral -> ast::Value
				= "#" i:identifier _
				{ ast::SymbolValue(i) }

			integerliteral -> ast::Value
				= "#" n:integer { ast::IntegerValue(n) }

			bitsliteral -> ast::Value
				= "'h" v:(hexchar+) _ {
					ast::VectorValue(Vec::from_fn(v.len()*4, |i| {
						let n = i/4;
						let b = i%4;
						ast::IntegerValue((v.as_slice()[n] & (1 << (4-b))) as i64)
					}))
				}
				/ "'" "b"? v:(binbit+) _ 
					{ ast::VectorValue(v.iter().map(|&b| ast::IntegerValue(b as i64)).collect()) }

				hexchar -> u8
					= [0-9a-fA-F]
					{ from_str_radix::<u8>(match_str, 16).unwrap() }

				binbit -> bool
					= "0" {false} / "1" {true}

			numberliteral -> ast::Value
				= v:floatnumber _ u:unit _
				{ ast::NumberValue(v) }

			unitliteral = unit { () }

				unit -> String
					= [a-zA-Z]+ { match_str.to_string() }
				    / "" { "".to_string() }

// Lexer

commasep = ( "," / TERMINATOR / &(__ [)\]]) ) __

WHITESPACE
  = [\u0009\u000B\u000C\u0020\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]
  / "\\" TERM

TERM
  = "\r"? "\n"

TERMINATOR
  = (comment? TERM)+

BREAK = _ TERMINATOR __

comment = "//" (!TERM .)*

_ = WHITESPACE*
__ = (WHITESPACE / TERMINATOR)*

identifier -> String = [a-zA-Z_][0-9a-zA-Z_]*
	{ match_str.to_string() }

integer -> i64 = "-"?[0-9]+
	{ from_str::<i64>(match_str).unwrap() }

floatnumber -> f64 = "-"?[0-9]+("."[0-9]+)?
	{ from_str::<f64>(match_str).unwrap() }
